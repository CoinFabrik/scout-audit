"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9102],{7224:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"detectors/substrate/equal-addresses","title":"Equal addresses","description":"Description","source":"@site/docs/detectors/substrate/equal-addresses.md","sourceDirName":"detectors/substrate","slug":"/detectors/substrate/equal-addresses","permalink":"/scout-audit/docs/detectors/substrate/equal-addresses","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/substrate/equal-addresses.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Empty expect","permalink":"/scout-audit/docs/detectors/substrate/empty-expect"},"next":{"title":"Incorrect exponentiation","permalink":"/scout-audit/docs/detectors/substrate/incorrect-exponentiation"}}');var r=t(5105),a=t(6755);const i={},c="Equal addresses",o={},d=[{value:"Description",id:"description",level:2},{value:"Why is it bad?",id:"why-is-it-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"equal-addresses",children:"Equal addresses"})}),"\n",(0,r.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Category: ",(0,r.jsx)(s.code,{children:"Error Handling"})]}),"\n",(0,r.jsxs)(s.li,{children:["Severity: ",(0,r.jsx)(s.code,{children:"Minor"})]}),"\n",(0,r.jsxs)(s.li,{children:["Detectors: ",(0,r.jsx)(s.a,{href:"https://github.com/CoinFabrik/scout-audit/blob/main/detectors/substrate-pallets/equal-addresses/src/lib.rs",children:"equal-addresses"})]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Functions that receive two addresses as parameters should include a check to ensure they are not the same. This ensures that the addresses represent distinct entities within the system"}),"\n",(0,r.jsx)(s.h2,{id:"why-is-it-bad",children:"Why is it bad?"}),"\n",(0,r.jsx)(s.p,{children:"Failing to verify that two input addresses are distinct can lead to unexpected behavior in smart contracts. For instance, when performing actions such as transferring tokens back to itself, signing permissions, or granting approvals between two addresses, allowing identical addresses can cause erroneous or redundant behavior and a waste of gas."}),"\n",(0,r.jsx)(s.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsx)(s.p,{children:"Consider the following substrate pallet:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'pub fn check_balance(\norigin: OriginFor<T>,\nfrom: T::AccountId,\n) -> DispatchResult {\nlet origin = ensure_signed(origin)?;\n\nlet user_balance = Self::balance_of(&origin);\nlet sender_balance = Self::balance_of(&from);\n\n            ensure!(sender_balance >= user_balance, "Insufficient balance");\n\n            Ok(())\n        }\n'})}),"\n",(0,r.jsx)(s.p,{children:"This function takes two addresses as parameters and checks their respective balances. If the two addresses are identical, the function ends up checking the balance of the same accounts, resulting in unnecessary gas consumption"}),"\n",(0,r.jsx)(s.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(s.p,{children:"Consider checking if the addresses are the same:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'pub fn check_balance(origin: OriginFor<T>, from: T::AccountId) -> DispatchResult {\nlet origin = ensure_signed(origin)?;\n\n            if from == origin {\n                return Err(Error::<T>::SameAddresses.into());\n            }\n            let user_balance = Self::balance_of(&origin);\n            let sender_balance = Self::balance_of(&from);\n\n            ensure!(sender_balance >= user_balance, "Insufficient balance");\n\n            Ok(())\n        }\n'})}),"\n",(0,r.jsx)(s.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsx)(s.p,{children:"First, it checks if the function has two or more parameters that are addresses and stores them in a vector. Then, it constructs a control flow graph using the MIR (Mid-level Intermediate Representation) of Dylint and LateLintPass. It checks whether there is a boolean condition within the function that compares the two parameters. If such a check exists, the corresponding elements are removed from the vector, and the process moves to the next function. If no check is found, throws a warning."})]})}function u(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},6755:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>c});var n=t(8101);const r={},a=n.createContext(r);function i(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);