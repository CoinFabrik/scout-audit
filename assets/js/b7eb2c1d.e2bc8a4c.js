"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[8545],{3280:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"detectors/soroban/ineffective-extend-ttl","title":"Ineffective extend_ttl","description":"Description","source":"@site/docs/detectors/soroban/28-ineffective-extend-ttl.md","sourceDirName":"detectors/soroban","slug":"/detectors/soroban/ineffective-extend-ttl","permalink":"/scout-audit/docs/detectors/soroban/ineffective-extend-ttl","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/soroban/28-ineffective-extend-ttl.md","tags":[],"version":"current","sidebarPosition":28,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Avoid Vec or Map inputs","permalink":"/scout-audit/docs/detectors/soroban/avoid-vec-map-input"},"next":{"title":"Contract import dependency","permalink":"/scout-audit/docs/detectors/soroban/contract-import-dependency"}}');var r=n(7259),i=n(9087);const o={},a="Ineffective extend_ttl",c={},l=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"ineffective-extend_ttl",children:"Ineffective extend_ttl"})}),"\n",(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Category: ",(0,r.jsx)(t.code,{children:"Best practices"})]}),"\n",(0,r.jsxs)(t.li,{children:["Severity: ",(0,r.jsx)(t.code,{children:"Low"})]}),"\n",(0,r.jsxs)(t.li,{children:["Detector: ",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/ineffective-extend-ttl",children:(0,r.jsx)(t.code,{children:"ineffective-extend-ttl"})})]}),"\n",(0,r.jsxs)(t.li,{children:["Test Cases: ",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/ineffective-extend-ttl/ineffective-extend-ttl-1",children:(0,r.jsx)(t.code,{children:"ineffective-extend-ttl-1"})})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Soroban exposes ",(0,r.jsx)(t.code,{children:"extend_ttl"})," to prolong the lifetime of storage entries. The call receives a threshold value that gates when the entry should be refreshed and the target TTL to extend the entry to. If the target TTL is the same as or lower than the threshold, the extension becomes wasteful because it triggers on every contract invocation instead of only when needed."]}),"\n",(0,r.jsx)(t.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,r.jsxs)(t.p,{children:["When the target TTL does not exceed the refresh threshold, ",(0,r.jsx)(t.code,{children:"extend_ttl"})," fires on ",(0,r.jsx)(t.strong,{children:"every"})," contract invocation, wasting resources. Each call pays to extend the TTL to a value that is at or below the threshold, meaning the next invocation will find the entry below the threshold again and repeat the extension unnecessarily. This defeats the purpose of the threshold parameter, which is designed to limit how frequently extensions occur."]}),"\n",(0,r.jsx)(t.p,{children:"Instead of extending only when the entry is about to expire, the contract pays for TTL extensions on every single call, consuming resources for no practical benefit."}),"\n",(0,r.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsx)(t.p,{children:"Consider the following excerpt:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"env.storage().temporary().set(&CACHE_KEY, &entry);\nlet ttl = 100_000;\nenv.storage().temporary().extend_ttl(&CACHE_KEY, ttl, ttl);\n"})}),"\n",(0,r.jsx)(t.p,{children:"Because both parameters use the same value, each invocation extends the TTL to exactly the threshold value. Since the TTL will always be at or below the threshold after any ledger passes, every subsequent invocation triggers another extension, wasting resources on every call."}),"\n",(0,r.jsxs)(t.p,{children:["The vulnerable example can be found ",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/ineffective-extend-ttl/ineffective-extend-ttl-1/vulnerable-example",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"env.storage()\n    .temporary()\n    .extend_ttl(&CACHE_KEY, 50_000, 100_000);\n"})}),"\n",(0,r.jsxs)(t.p,{children:["By setting the target TTL higher than the refresh threshold, the entry is only refreshed when its remaining lifetime falls below the threshold. This allows the entry to age naturally between refreshes, reducing unnecessary extension calls and saving resources. Alternatively, the contract can avoid calling ",(0,r.jsx)(t.code,{children:"extend_ttl"})," altogether and manage expiration through business logic."]}),"\n",(0,r.jsxs)(t.p,{children:["The remediated example can be found ",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/ineffective-extend-ttl/ineffective-extend-ttl-1/remediated-example",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsxs)(t.p,{children:["The detector looks for ",(0,r.jsx)(t.code,{children:"extend_ttl"})," calls on any Soroban storage interface. It warns whenever the threshold and target refer to the same binding, or when both resolve to constant integer values and the target does not strictly exceed the threshold (including values imported through ",(0,r.jsx)(t.code,{children:"const"})," items). This ensures the lint fires even when contracts centralize TTL thresholds in shared constants."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},9087:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6363);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);