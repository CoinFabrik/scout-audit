"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[953],{1013:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"detectors/substrate/avoid-debug-info","title":"Avoid debug!() info!()","description":"Description","source":"@site/docs/detectors/substrate/avoid-debug-info.md","sourceDirName":"detectors/substrate","slug":"/detectors/substrate/avoid-debug-info","permalink":"/scout-audit/docs/detectors/substrate/avoid-debug-info","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/substrate/avoid-debug-info.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Assert violation","permalink":"/scout-audit/docs/detectors/substrate/assert-violation"},"next":{"title":"Avoid DispatchError::Other()","permalink":"/scout-audit/docs/detectors/substrate/avoid-dispatch-error-other"}}');var o=t(5105),i=t(3881);const r={},d="Avoid debug!() info!()",a={},c=[{value:"Description",id:"description",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediation",id:"remediation",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"avoid-debug-info",children:"Avoid debug!() info!()"})}),"\n",(0,o.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Category: ",(0,o.jsx)(n.code,{children:"Best Practices"})]}),"\n",(0,o.jsxs)(n.li,{children:["Severity: ",(0,o.jsx)(n.code,{children:"Minor"})]}),"\n",(0,o.jsxs)(n.li,{children:["Detectors: ",(0,o.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-audit/tree/main/detectors/substrate-pallets/avoid-debug-info",children:(0,o.jsx)(n.code,{children:"avoid-debug-info"})})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The use of debugging macros, such as ",(0,o.jsx)(n.code,{children:"debug!()"})," and ",(0,o.jsx)(n.code,{children:"info!()"}),", is useful during development and testing; however, these macros are not recommended for production and are considered a bad practice. Additionally, each operation that stores data in memory requires the virtual machine to perform additional work, which increases the gas costs needed for the transaction. Instead, consider using events emitting to log relevant data more efficiently and reduce unnecessary gas costs."]}),"\n",(0,o.jsx)(n.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,o.jsx)(n.p,{children:"Consider the following function:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[pallet::call_index(0)]\npub fn unsafe_check_value(origin: OriginFor<T>, threshold: u32) -> DispatchResult {\n    let who = ensure_signed(origin)?;\n\n    let stored_value = Value::<T>::get().unwrap_or_default();\n\n    debug!(\n        "Stored value: {:?}, Threshold: {:?}",\n        stored_value, threshold\n    );\n    info!("Consider providing a threshold lower than the actual stored value");\n\n    Self::deposit_event(Event::ValueChecked {\n        who,\n        value: stored_value,\n    });\n    Ok(())\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"unsafe_check_value"})," function logs data and provides a suggestion using ",(0,o.jsx)(n.code,{children:"debug!()"})," and ",(0,o.jsx)(n.code,{children:"info!()"})," macros. These macros, while helpful during development, are inefficient in production because they increase gas costs due to unnecessary resource consumption."]}),"\n",(0,o.jsxs)(n.p,{children:["The vulnerable code example can be found ",(0,o.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-audit/tree/main/test-cases/substrate-pallets/avoid-debug-info/vulnerable/vulnerable-1",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"remediation",children:"Remediation"}),"\n",(0,o.jsxs)(n.p,{children:["Replace the macros with structured events to reduce gas costs in production. If the ",(0,o.jsx)(n.code,{children:"stored_value"})," is less than the threshold, emit a ",(0,o.jsx)(n.code,{children:"ValueTooLow"})," event with the relevant details and return an error. This ensures proper handling of invalid conditions while maintaining efficiency and aligning the code with best practices for production environments."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"#[pallet::call_index(0)]\npub fn unsafe_check_value(origin: OriginFor<T>, threshold: u32) -> DispatchResult {\n    let who = ensure_signed(origin)?;\n\n    let stored_value = Value::<T>::get().unwrap_or_default();\n    if stored_value < threshold {\n        Self::deposit_event(Event::ValueTooLow {\n            who: who.clone(),\n            stored_value,\n            threshold,\n        });\n        return Err(Error::<T>::ValueTooLow.into());\n    }\n    Self::deposit_event(Event::ValueChecked {\n        who,\n        value: stored_value,\n    });\n    Ok(())\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The remediated code example can be found ",(0,o.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-audit/tree/main/test-cases/substrate-pallets/avoid-debug-info/remediated/remediated-1",children:"here"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},3881:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var s=t(8101);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);