"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[21],{648:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"detectors/soroban/set-contract-storage","title":"Set contract storage","description":"Description","source":"@site/docs/detectors/soroban/8-set-contract-storage.md","sourceDirName":"detectors/soroban","slug":"/detectors/soroban/set-contract-storage","permalink":"/scout-audit/docs/detectors/soroban/set-contract-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/soroban/8-set-contract-storage.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Avoid core::mem::forget usage","permalink":"/scout-audit/docs/detectors/soroban/avoid-core-mem-forget"},"next":{"title":"Avoid panic error","permalink":"/scout-audit/docs/detectors/soroban/avoid-panic-error"}}');var s=r(5105),o=r(3881);const a={},c="Set contract storage",i={},d=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"set-contract-storage",children:"Set contract storage"})}),"\n",(0,s.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Category: ",(0,s.jsx)(t.code,{children:"Authorization"})]}),"\n",(0,s.jsxs)(t.li,{children:["Severity: ",(0,s.jsx)(t.code,{children:"Critical"})]}),"\n",(0,s.jsxs)(t.li,{children:["Detector: ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/set-contract-storage",children:(0,s.jsx)(t.code,{children:"set-contract-storage"})})]}),"\n",(0,s.jsxs)(t.li,{children:["Test Cases: ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-1",children:(0,s.jsx)(t.code,{children:"set-contract-storage-1"})})," ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-2",children:(0,s.jsx)(t.code,{children:"set-contract-storage-2"})})," ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-3",children:(0,s.jsx)(t.code,{children:"set-contract-storage-3"})}),"  ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-4",children:(0,s.jsx)(t.code,{children:"set-contract-storage-4"})})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Smart contracts can store important information in memory which changes through the contract's lifecycle. Changes happen via user interaction with the smart contract. An unauthorized set contract storage issue happens when a smart contract call allows a user to set or modify contract memory when he was not supposed to be authorized."}),"\n",(0,s.jsx)(t.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,s.jsx)(t.p,{children:"Unauthorized access to storage by a user can lead to serious issues, as they might manipulate memory data to attack the contract."}),"\n",(0,s.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,s.jsxs)(t.p,{children:["Consider the following ",(0,s.jsx)(t.code,{children:"Soroban"})," contract:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"\n #[contractimpl]\nimpl SetContractStorage {\n    /// Increment an internal counter; return the new value.\n    pub fn increment(env: Env, user: Address) -> u32 {\n        let storage = env.storage().instance();\n        let mut count: u32 = storage.get(&user).unwrap_or_default();\n        count += 1;\n        storage.set(&user, &count);\n        storage.extend_ttl(100, 100);\n        count\n    }\n}    \n\n"})}),"\n",(0,s.jsx)(t.p,{children:"In this example we see that any user may access the SetContractStorage() function, and therefore modify the value of the internal counter."}),"\n",(0,s.jsxs)(t.p,{children:["The code example can be found ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-1/vulnerable-example",children:"here"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,s.jsx)(t.p,{children:"Arbitrary users should not have control over keys because it implies writing any value of a mapping, lazy variable, or the main struct of the contract located in position 0 of the storage. To prevent this issue, set access control and proper authorization validation for the SetContractStorage() function."}),"\n",(0,s.jsx)(t.p,{children:"For example, the code below, ensures only the authorized users can call SetContractStorage()."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"\n #[contractimpl]\nimpl SetContractStorage {\n    /// Increment an internal counter; return the new value.\n    pub fn increment(env: Env, user: Address) -> u32 {\n        user.require_auth();\n        let storage = env.storage().instance();\n        let mut count: u32 = storage.get(&user).unwrap_or_default();\n        count += 1;\n        storage.set(&user, &count);\n        storage.extend_ttl(100, 100);\n        count\n    }\n}\n        \n"})}),"\n",(0,s.jsxs)(t.p,{children:["The remediated code example can be found ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/set-contract-storage/set-contract-storage-1/remediated-example",children:"here"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,s.jsx)(t.p,{children:"Checks for calls to env.storage() without a prior call to env.require_auth()."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},3881:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>c});var n=r(8101);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);