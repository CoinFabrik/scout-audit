"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7646],{7529(e,t,n){n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"detectors/soroban/dos-unexpected-revert-with-storage","title":"DoS unexpected revert with storage","description":"Description","source":"@site/docs/detectors/soroban/17-dos-unexpected-revert-with-storage.md","sourceDirName":"detectors/soroban","slug":"/detectors/soroban/dos-unexpected-revert-with-storage","permalink":"/scout-audit/docs/detectors/soroban/dos-unexpected-revert-with-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/soroban/17-dos-unexpected-revert-with-storage.md","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Unprotected mapping operation","permalink":"/scout-audit/docs/detectors/soroban/unprotected-mapping-operation"},"next":{"title":"Unrestricted transfer from","permalink":"/scout-audit/docs/detectors/soroban/unrestricted-transfer-from"}}');var r=n(2615),s=n(7545);const o={},d="DoS unexpected revert with storage",i={},c=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2},{value:"References",id:"references",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"dos-unexpected-revert-with-storage",children:"DoS unexpected revert with storage"})}),"\n",(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Category: ",(0,r.jsx)(t.code,{children:"Authorization"})]}),"\n",(0,r.jsxs)(t.li,{children:["Severity: ",(0,r.jsx)(t.code,{children:"Critical"})]}),"\n",(0,r.jsxs)(t.li,{children:["Detector:\n",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/dos-unexpected-revert-with-storage",children:(0,r.jsx)(t.code,{children:"dos-unexpected-revert-with-storage"})})]}),"\n",(0,r.jsxs)(t.li,{children:["Test Cases:\n",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/dos-unexpected-revert-with-storage/vulnerable/vulnerable-1",children:(0,r.jsx)(t.code,{children:"dos-unexpected-revert-with-storage-1"})}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/dos-unexpected-revert-with-storage/vulnerable/vulnerable-2",children:(0,r.jsx)(t.code,{children:"dos-unexpected-revert-with-storage-2"})})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This issue of DoS through unexpected revert arises when a smart contract does\nnot handle storage size errors correctly, and a user can add an excessive number\nof entries, leading to an unexpected revert of transactions by other users and a\nDenial of Service."}),"\n",(0,r.jsx)(t.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,r.jsxs)(t.p,{children:["In Soroban smart contracts, a Denial of Service (DoS) issue through unexpected\nreverts can occur if the contract does not properly manage storage limits or\nhandle errors when the storage capacity is exceeded. If a user adds an excessive\nnumber of entries (to a ",(0,r.jsx)(t.code,{children:"Vec"})," or ",(0,r.jsx)(t.code,{children:"Map"}),"), it could trigger a revert, causing\nsubsequent transactions by other users to fail unexpectedly, leading to a\npotential Denial of Service."]}),"\n",(0,r.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsxs)(t.p,{children:["The smart contract we developed for this example allows users to vote for one of\ndifferent candidates. The smart contract contains a struct named\n",(0,r.jsx)(t.code,{children:"UnexpectedRevert"})," that stores the total number of votes, a list of candidates,\ntheir votes, and whether an account has voted. It also stores information about\nthe most voted candidate and when the vote will end."]}),"\n",(0,r.jsxs)(t.p,{children:["Consider the following ",(0,r.jsx)(t.code,{children:"Soroban"})," contract:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'#![no_std]\n\nuse soroban_sdk::{\n    contract, contracterror, contractimpl, contracttype, symbol_short, Address, Env, Map, String,\n    Symbol, Vec,\n};\n\n#[contracterror]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n#[repr(u32)]\npub enum URError {\n    // Unexpected Revert Error\n    AccountAlreadyVoted = 1,\n    CandidateAlreadyAdded = 2,\n    CandidateDoesntExist = 3,\n    Overflow = 4,\n    TimestampBeforeCurrentBlock = 5,\n    VoteEnded = 6,\n}\n\n#[derive(Debug, Clone, PartialEq)]\n#[contracttype]\npub struct State {\n    total_votes: u64,\n    candidates: Vec<Address>,\n    votes: Map<Address, u64>,\n    already_voted: Map<Address, bool>,\n    most_voted_candidate: Address,\n    candidate_votes: u64,\n    vote_timestamp_end: u64,\n}\n\nconst STATE: Symbol = symbol_short!("STATE");\n\n#[contract]\npub struct UnexpectedRevert;\n\n#[contractimpl]\nimpl UnexpectedRevert {\n    pub fn init(env: Env, end_timestamp: u64) -> Result<State, URError> {\n        if end_timestamp <= env.ledger().timestamp() {\n            return Err(URError::TimestampBeforeCurrentBlock);\n        }\n\n        let zero_string: String = String::from_str(&env, "00000000000000000000000000000000");\n        let zero_addr = Address::from_string(&zero_string); //CHECK\n        let state = State {\n            total_votes: 0,\n            most_voted_candidate: zero_addr,\n            candidate_votes: 0,\n            candidates: Vec::new(&env),\n            already_voted: Map::new(&env),\n            votes: Map::new(&env),\n            vote_timestamp_end: end_timestamp,\n        };\n\n        env.storage().instance().set(&STATE, &state);\n        Ok(state)\n    }\n\n    pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n        let mut state = Self::get_state(env.clone());\n        if Self::vote_ended(env.clone()) {\n            return Err(URError::VoteEnded);\n        }\n        if state.already_voted.contains_key(caller.clone()) {\n            Err(URError::AccountAlreadyVoted)\n        } else {\n            // VULNERABLE: Vec push without authorization\n            state.candidates.push_back(candidate.clone());\n            // VULNERABLE: Map set without authorization\n            state.votes.set(candidate, 0);\n            Ok(())\n        }\n    }\n\n    pub fn get_votes_for_a_candidate(env: Env, candidate: Address) -> Result<u64, URError> {\n        let state = Self::get_state(env.clone());\n        state\n            .votes\n            .get(candidate)\n            .ok_or(URError::CandidateDoesntExist)\n    }\n\n    pub fn most_voted_candidate_votes(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.candidate_votes\n    }\n\n    pub fn most_voted_candidate(env: Env) -> Address {\n        let state = Self::get_state(env);\n        state.most_voted_candidate\n    }\n\n    pub fn get_total_votes(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.total_votes\n    }\n\n    pub fn get_total_candidates(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.candidates.len() as u64\n    }\n\n    pub fn get_candidate(env: Env, index: u32) -> Result<Address, URError> {\n        let state = Self::get_state(env);\n        if index < state.candidates.len() {\n            Ok(state.candidates.get(index).unwrap())\n        } else {\n            Err(URError::CandidateDoesntExist)\n        }\n    }\n\n    pub fn account_has_voted(env: Env, account: Address) -> bool {\n        let state = Self::get_state(env);\n        state.already_voted.get(account).unwrap_or(false)\n    }\n\n    pub fn vote(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n        caller.require_auth();\n        let mut state = Self::get_state(env.clone());\n        if Self::vote_ended(env.clone()) {\n            return Err(URError::VoteEnded);\n        }\n\n        if state.already_voted.contains_key(caller.clone()) {\n            Err(URError::AccountAlreadyVoted)\n        } else {\n            state.already_voted.set(caller, true);\n            let votes = state\n                .votes\n                .get(candidate.clone())\n                .ok_or(URError::CandidateDoesntExist)?\n                .checked_add(1)\n                .ok_or(URError::Overflow)?;\n            state.votes.set(candidate.clone(), votes);\n            state.total_votes.checked_add(1).ok_or(URError::Overflow)?;\n            if state.candidate_votes < votes {\n                state.candidate_votes = votes;\n                state.most_voted_candidate = candidate;\n            }\n            Ok(())\n        }\n    }\n\n    pub fn vote_ended(env: Env) -> bool {\n        let state = Self::get_state(env.clone());\n        state.vote_timestamp_end <= env.ledger().timestamp()\n    }\n\n    pub fn get_state(env: Env) -> State {\n        env.storage().instance().get(&STATE).unwrap()\n    }\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"The smart contract has several functions that allow adding a candidate, getting\nvotes for a specific candidate, getting the account ID of the most voted\ncandidate, getting the total votes, getting the total number of candidates,\ngetting a candidate by index, checking if an account has voted, and voting for a\ncandidate."}),"\n",(0,r.jsxs)(t.p,{children:["In this case, we see that a ",(0,r.jsx)(t.code,{children:"Vec"})," is being used to store the array of\ncandidates, and a ",(0,r.jsx)(t.code,{children:"Map"})," is used to store votes. Notice how the ",(0,r.jsx)(t.code,{children:"candidates"}),"\narray ",(0,r.jsx)(t.code,{children:"push"})," operation and the ",(0,r.jsx)(t.code,{children:"votes"})," map ",(0,r.jsx)(t.code,{children:"set"})," operation have no access\ncontrol or proper storage management in the function ",(0,r.jsx)(t.code,{children:"add_candidate()"}),". This can\ncause a revert if the storage limit is reached or the data structure becomes too\nlarge."]}),"\n",(0,r.jsxs)(t.p,{children:["The code example can be found\n",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/blob/main/test-cases/dos-unexpected-revert-with-storage/vulnerable/vulnerable-1",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(t.p,{children:"This issue can be addressed in different ways."}),"\n",(0,r.jsx)(t.p,{children:"On the one hand, if the amount of candidates is going to be limited, and only\nauthorized users are going to add new candidates, then enforcing this\nauthorization would be a sufficient fix to prevent attackers from filling the\nstorage and producing a denial of service attack."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n    let mut state = Self::get_state(env.clone());\n     // Require authorization from an admin set at contract initialization.\n    state.admin.require_auth(); \n    if Self::vote_ended(env.clone()) {\n        return Err(URError::VoteEnded);\n    }\n    if state.already_voted.contains_key(caller.clone()) {\n        return Err(URError::AccountAlreadyVoted); \n    } else {\n        state.candidates.push_back(candidate.clone());\n        state.votes.set(candidate, 0);\n        Ok(())\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Alternatively, if any user should be authorized to add new candidates, a\ndifferent data structure should be used, one without the limitations of a\nvector. For example, a dictionary can be implemented in Soroban by defining a\nstruct for the ",(0,r.jsx)(t.code,{children:"Candidate"}),", accessible through a ",(0,r.jsx)(t.code,{children:"DataKey"})," enum like the one we\nhave here. This data structure does not have the storage limitations of vectors,\nand using it to handle new candidates would prevent the issue."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:" pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n      caller.require_auth();\n      let mut state = Self::get_state(env.clone());\n      if Self::vote_ended(env.clone()) {\n          return Err(URError::VoteEnded);\n      }\n      if Self::account_has_voted(env.clone(), caller.clone()) {\n          return Err(URError::AccountAlreadyVoted); \n      } else {\n          // Replace the vector with a mapping like structure made with a DataKey enum.\n          env.storage().instance().set(&DataKey::Candidate(candidate.clone()), &Candidate{votes: 0});\n          state.total_candidates += 1; \n          env.storage().instance().set(&DataKey::State, &state);\n          Ok(())\n      }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This remediated code example can be found\n",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/blob/main/test-cases/dos-unexpected-revert-with-storage/remediated/remediated-2",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsxs)(t.p,{children:["Checks if the contract uses ",(0,r.jsx)(t.strong,{children:"Vector"})," (",(0,r.jsx)(t.code,{children:"push_back"}),", ",(0,r.jsx)(t.code,{children:"push_front"}),") or ",(0,r.jsx)(t.strong,{children:"Map"}),"\n(",(0,r.jsx)(t.code,{children:"set"}),") operations to increase storage size without calling ",(0,r.jsx)(t.code,{children:"require_auth"}),"\npreviously."]}),"\n",(0,r.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://swcregistry.io/docs/SWC-113",children:"SWC-113"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert",children:"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/src/levels/King.sol",children:"Ethernaut: King"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},7545(e,t,n){n.d(t,{R:()=>o,x:()=>d});var a=n(9471);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);