"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4254],{457:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"detectors/substrate/divide-before-multiply","title":"Divide before multiply","description":"Description","source":"@site/docs/detectors/substrate/divide-before-multiply.md","sourceDirName":"detectors/substrate","slug":"/detectors/substrate/divide-before-multiply","permalink":"/scout-audit/docs/detectors/substrate/divide-before-multiply","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/substrate/divide-before-multiply.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Avoid unsafe block","permalink":"/scout-audit/docs/detectors/substrate/avoid-unsafe-block"},"next":{"title":"Empty expect","permalink":"/scout-audit/docs/detectors/substrate/empty-expect"}}');var r=i(3420),s=i(3774);const d={},a="Divide before multiply",o={},c=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2},{value:"References",id:"references",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"divide-before-multiply",children:"Divide before multiply"})}),"\n",(0,r.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Category: ",(0,r.jsx)(n.code,{children:"Arithmetic"})]}),"\n",(0,r.jsxs)(n.li,{children:["Severity: ",(0,r.jsx)(n.code,{children:"Medium"})]}),"\n",(0,r.jsxs)(n.li,{children:["Detectors: ",(0,r.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-audit/blob/main/detectors/rust/divide-before-multiply/src/lib.rs",children:(0,r.jsx)(n.code,{children:"divide-before-multiply"})})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In Rust, the order of operations can influence the precision of the result, especially in integer arithmetic."}),"\n",(0,r.jsx)(n.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,r.jsx)(n.p,{children:"Performing a division operation before a multiplication can lead to a loss of precision as division between integers might return zero."}),"\n",(0,r.jsx)(n.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsxs)(n.p,{children:["Consider the following ",(0,r.jsx)(n.code,{children:"Substrate pallet"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pallet::call_index(0)]\n        pub fn accumulate_dummy(\n            origin: OriginFor<T>,\n            increase_by: T::Balance,\n            numerator: T::Balance,\n            denominator: T::Balance,\n        ) -> DispatchResult {\n            let _sender = ensure_signed(origin)?;\n\n            <Dummy<T>>::mutate(|dummy| {\n                let new_dummy = dummy.map_or(increase_by, |d| {\n                    d.saturating_add(increase_by / denominator * numerator)\n                });\n                *dummy = Some(new_dummy);\n            });\n\n            Self::deposit_event(Event::AccumulateDummy {\n                balance: increase_by,\n            });\n\n            Ok(())\n        }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this contract, the ",(0,r.jsx)(n.code,{children:"accumulate_dummy"})," function creates a Dummy struct array by adding each element with the calculation of ",(0,r.jsx)(n.code,{children:"increase_by / denominator * numerator"}),". This last calculation divides the ",(0,r.jsx)(n.code,{children:"increase_by"})," by ",(0,r.jsx)(n.code,{children:"denominator"})," before multiplying it with ",(0,r.jsx)(n.code,{children:"numerator"}),". This could lead to a loss of precision if ",(0,r.jsx)(n.code,{children:"increase_by"})," is less than ",(0,r.jsx)(n.code,{children:"denominator"})," as the division would return ",(0,r.jsx)(n.code,{children:"0"}),". This could lead to incorrect calculations and potential financial loss in a real-world smart contract."]}),"\n",(0,r.jsx)(n.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(n.p,{children:"Reverse the order of operations to ensure multiplication occurs before division."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pallet::call_index(0)]\n        pub fn accumulate_dummy(\n            origin: OriginFor<T>,\n            increase_by: T::Balance,\n            numerator: T::Balance,\n            denominator: T::Balance,\n        ) -> DispatchResult {\n            let _sender = ensure_signed(origin)?;\n\n            <Dummy<T>>::mutate(|dummy| {\n                let new_dummy = dummy.map_or(increase_by, |d| {\n                    d.saturating_add(increase_by * numerator / denominator)\n                });\n                *dummy = Some(new_dummy);\n            });\n\n            Self::deposit_event(Event::AccumulateDummy {\n                balance: increase_by,\n            });\n\n            Ok(())\n        }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsx)(n.p,{children:"Checks the existence of a division before a multiplication."}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.a,{href:"https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators",children:["Rust documentation: ",(0,r.jsx)(n.code,{children:"Integer Division"})]})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},3774:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>a});var t=i(6672);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);