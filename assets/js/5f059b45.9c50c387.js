"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4699],{3821(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"detectors/substrate/saturating-arithmetic","title":"Saturating arithmetic","description":"Description","source":"@site/docs/detectors/substrate/saturating-arithmetic.md","sourceDirName":"detectors/substrate","slug":"/detectors/substrate/saturating-arithmetic","permalink":"/scout-audit/docs/detectors/substrate/saturating-arithmetic","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/substrate/saturating-arithmetic.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overflow-check","permalink":"/scout-audit/docs/detectors/substrate/overflow-check"},"next":{"title":"Unsafe expect","permalink":"/scout-audit/docs/detectors/substrate/unsafe-expect"}}');var r=n(2615),s=n(7545);const a={},c="Saturating arithmetic",d={},o=[{value:"Description",id:"description",level:2},{value:"Why is it bad?",id:"why-is-it-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"saturating-arithmetic",children:"Saturating arithmetic"})}),"\n",(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Issue Category: ",(0,r.jsx)(t.code,{children:"Arithmetic"})]}),"\n",(0,r.jsxs)(t.li,{children:["Issue Severity: ",(0,r.jsx)(t.code,{children:"Critical"})]}),"\n",(0,r.jsxs)(t.li,{children:["Detectors: ",(0,r.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-audit/tree/main/detectors/substrate-pallets/saturating-arithmetic/src/lib.rs",children:(0,r.jsx)(t.code,{children:"saturating-arithmetic"})})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Saturating arithmetic operations adjust the result to the maximum or minimum value allowed by the data type instead of causing an overflow. While this behavior prevents crashes, it can produce incorrect results. Consider checked arithmetic instead"}),"\n",(0,r.jsx)(t.h2,{id:"why-is-it-bad",children:"Why is it bad?"}),"\n",(0,r.jsx)(t.p,{children:"Saturating arithmetic clamps the result to the representation limit for the data type instead of overflowing. By doing this, it can generate logical errors in calculations, leading to unintended behavior without throwing any error or warning."}),"\n",(0,r.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsxs)(t.p,{children:["Consider the following ",(0,r.jsx)(t.code,{children:"Substrate pallet"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub fn accumulate_dummy(origin: OriginFor<T>, increase_by: T::Balance) -> DispatchResult {\n    let _sender = ensure_signed(origin)?;\n\n    <Dummy<T>>::mutate(|dummy| {\n        let new_dummy = dummy.map_or(increase_by, |d| d.saturating_add(increase_by));\n        *dummy = Some(new_dummy);\n    });\n\n    Self::deposit_event(Event::AccumulateDummy {\n        balance: increase_by,\n    });\n\n    Ok(())\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["By calling ",(0,r.jsx)(t.code,{children:"d.saturating_add(increase_by)"}),", it can lead tu unexpected behavior."]}),"\n",(0,r.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(t.p,{children:"Using checked arithmetic, which explicitly handles overflows by returning an error or panic, ensures that unexpected conditions are caught and addressed."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub fn accumulate_dummy(origin: OriginFor<T>, increase_by: T::Balance) -> DispatchResult {\n    let _sender = ensure_signed(origin)?;\n\n    let mut error = Ok(());\n    <Dummy<T>>::mutate(|dummy| {\n        let new_dummy = dummy.map_or(Some(increase_by), |d| d.checked_add(&increase_by));\n        if new_dummy.is_none() {\n            error = Err(Error::<T>::IntegerOverflow);\n            return;\n        }\n        *dummy = new_dummy;\n    });\n\n    error?;\n\n    Self::deposit_event(Event::AccumulateDummy {\n        balance: increase_by,\n    });\n\n    Ok(())\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsxs)(t.p,{children:["Checks the use of saturating calls such as: ",(0,r.jsx)(t.code,{children:"saturating_add"}),", ",(0,r.jsx)(t.code,{children:"saturating_mul"}),", ",(0,r.jsx)(t.code,{children:"saturating_dec"}),", etc."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},7545(e,t,n){n.d(t,{R:()=>a,x:()=>c});var i=n(9471);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);