"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8687],{3881:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(8101);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},5356:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"detectors/soroban/token-interface-events","title":"Token interface events","description":"Description","source":"@site/docs/detectors/soroban/23-token-interface-events.md","sourceDirName":"detectors/soroban","slug":"/detectors/soroban/token-interface-events","permalink":"/scout-audit/docs/detectors/soroban/token-interface-events","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/soroban/23-token-interface-events.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Storage change events","permalink":"/scout-audit/docs/detectors/soroban/storage-change-events"},"next":{"title":"Front running","permalink":"/scout-audit/docs/detectors/soroban/front-running"}}');var a=t(5105),r=t(3881);const o={},i="Token interface events",c={},l=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"token-interface-events",children:"Token interface events"})}),"\n",(0,a.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Category: ",(0,a.jsx)(n.code,{children:"Best practices"})]}),"\n",(0,a.jsxs)(n.li,{children:["Severity: ",(0,a.jsx)(n.code,{children:"Medium"})]}),"\n",(0,a.jsxs)(n.li,{children:["Detectors: ",(0,a.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/token-interface-events",children:(0,a.jsx)(n.code,{children:"token-interface-events"})})]}),"\n",(0,a.jsxs)(n.li,{children:["Test Cases: ",(0,a.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/token-interface-events/token-interface-events-1",children:(0,a.jsx)(n.code,{children:"token-interface-events-1"})})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In Rust, the token contracts have a special interface with certain requirements. One of these requirements is related to events; this requirement states that token functions must emit the events in the specified format. If this does not happen, the contract will have potential errors."}),"\n",(0,a.jsx)(n.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,a.jsx)(n.p,{children:"If the token functions do not emit events, the following errors may occur:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Token standard compliance"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Transparency: Events provide a transparent way to log and broadcast important actions like token transfers, approvals, and minting/burning. This transparency is crucial for users, developers, and external systems to monitor and react to contract activities."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Interoperability: Many decentralized applications (dApps) rely on events to interact with tokens. Without events, these applications might not be able to function correctly, as they would have no way of knowing when a transfer or other important action has occurred. Also, off-chain systems, like wallets, exchanges, and block explorers, use events to track token activity. If events are not implemented, these systems may encounter errors in providing accurate and real-time information about the token."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Debugging and Auditing: Events are very helpful for debugging and auditing smart contracts. They are useful because they provide detailed information about what happened in the contract during execution."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,a.jsxs)(n.p,{children:["Consider the following ",(0,a.jsx)(n.code,{children:"Soroban"})," contract:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"\n  fn transfer(env: Env, from: Address, to: Address, amount: i128) {\n        from.require_auth();\n        let from_balance = Self::balance(env.clone(), from.clone());\n        let to_balance = Self::balance(env.clone(), to.clone());\n        assert!(from_balance >= amount);\n        env.storage()\n            .instance()\n            .set(&DataKey::Balance(from), &(from_balance - amount));\n        env.storage()\n            .instance()\n            .set(&DataKey::Balance(to), &(to_balance + amount));\n    }\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"transfer()"})," function does not emit an event."]}),"\n",(0,a.jsxs)(n.p,{children:["The code example can be found ",(0,a.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/token-interface-events/token-interface-events-1/vulnerable-example",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"  fn transfer(env: Env, from: Address, to: Address, amount: i128) {\n        from.require_auth();\n        let from_balance = Self::balance(env.clone(), from.clone());\n        let to_balance = Self::balance(env.clone(), to.clone());\n        assert!(from_balance >= amount);\n        env.storage()\n            .instance()\n            .set(&DataKey::Balance(from.clone()), &(from_balance - amount));\n        env.storage()\n            .instance()\n            .set(&DataKey::Balance(to.clone()), &(to_balance + amount));\n\n        TokenUtils::new(&env).events().transfer(from, to, amount);\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"transfer()"})," function emits an event."]}),"\n",(0,a.jsxs)(n.p,{children:["The remediated code example can be found ",(0,a.jsx)(n.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/token-interface-events/token-interface-events-1/remediated-example",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,a.jsx)(n.p,{children:"If the token interface trait is being used, check if all of the token's functions emit events."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);