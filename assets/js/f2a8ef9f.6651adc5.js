"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4792],{3774:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6672);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},6463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"detectors/rust/avoid-panic-error","title":"Avoid panic error","description":"Description","source":"@site/docs/detectors/rust/avoid-panic-error.md","sourceDirName":"detectors/rust","slug":"/detectors/rust/avoid-panic-error","permalink":"/scout-audit/docs/detectors/rust/avoid-panic-error","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/rust/avoid-panic-error.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Assert violation","permalink":"/scout-audit/docs/detectors/rust/assert-violation"},"next":{"title":"Avoid unsafe block","permalink":"/scout-audit/docs/detectors/rust/avoid-unsafe-block"}}');var s=n(3420),r=n(3774);const o={},a="Avoid panic error",c={},d=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"avoid-panic-error",children:"Avoid panic error"})}),"\n",(0,s.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Category: ",(0,s.jsx)(t.code,{children:"Validations and error handling"})]}),"\n",(0,s.jsxs)(t.li,{children:["Severity: ",(0,s.jsx)(t.code,{children:"Enhancement"})]}),"\n",(0,s.jsxs)(t.li,{children:["Detector: ",(0,s.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-audit/blob/main/detectors/substrate-pallets/avoid-panic-error/src/lib.rs",children:(0,s.jsx)(t.code,{children:"avoid-panic-error"})})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The panic! macro is used to stop execution when a condition is not met. This is useful for testing and prototyping, but should be avoided in production code."}),"\n",(0,s.jsxs)(t.p,{children:["Using ",(0,s.jsx)(t.code,{children:"Result"})," as return type for functions that can fail is the idiomatic way to handle errors in Rust. The ",(0,s.jsx)(t.code,{children:"Result"})," type is an enum that can be either ",(0,s.jsx)(t.code,{children:"Ok"})," or ",(0,s.jsx)(t.code,{children:"Err"}),". The ",(0,s.jsx)(t.code,{children:"Err"})," variant can contain an error message. The ",(0,s.jsx)(t.code,{children:"?"})," operator can be used to propagate the error message to the caller."]}),"\n",(0,s.jsx)(t.p,{children:"This way, the caller can decide how to handle the error, although the state of the contract is always reverted on the callee."}),"\n",(0,s.jsx)(t.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,s.jsxs)(t.p,{children:["The usage of ",(0,s.jsx)(t.code,{children:"panic!"})," is not recommended because it will stop the execution of the caller contract. This could lead the contract to an inconsistent state if the execution stops in the middle of state changes. Additionally, if execution stops, it could cause a transaction to fail."]}),"\n",(0,s.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,s.jsx)(t.p,{children:"Consider the following snippet code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'pub fn unsafe_check_value(origin: OriginFor<T>, threshold: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let stored_value = Value::<T>::get().unwrap_or_default();\n            if stored_value < threshold {\n                panic!("Value is too low!");\n            }\n\n            Self::deposit_event(Event::ValueChecked {\n                who,\n                value: stored_value,\n            });\n            Ok(())\n        }\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This function panics if ",(0,s.jsx)(t.code,{children:"stored_value"})," is less than ",(0,s.jsx)(t.code,{children:"threshold"}),", disallowing the caller to handle the error in a different way, and completely stopping execution of the caller contract.\nThe usage of panic! in this example, is not recommended because it will stop the execution of the caller contract."]}),"\n",(0,s.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,s.jsx)(t.p,{children:"A possible remediation goes as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub fn unsafe_check_value(origin: OriginFor<T>, threshold: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let stored_value = Value::<T>::get().unwrap_or_default();\n            if stored_value < threshold {\n                return Err(Error::<T>::ValueTooLow.into());\n            }\n\n            Self::deposit_event(Event::ValueChecked {\n                who,\n                value: stored_value,\n            });\n            Ok(())\n        }\n"})}),"\n",(0,s.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,s.jsxs)(t.p,{children:["Checks the use of the macro ",(0,s.jsx)(t.code,{children:"panic!"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);