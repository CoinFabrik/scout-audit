"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4360],{5182:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"detectors/soroban/iterators-over-indexing","title":"Iterators over indexing","description":"Description","source":"@site/docs/detectors/soroban/14-iterators-over-indexing.md","sourceDirName":"detectors/soroban","slug":"/detectors/soroban/iterators-over-indexing","permalink":"/scout-audit/docs/detectors/soroban/iterators-over-indexing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/soroban/14-iterators-over-indexing.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Unused return enum","permalink":"/scout-audit/docs/detectors/soroban/unused-return-enum"},"next":{"title":"Assert violation","permalink":"/scout-audit/docs/detectors/soroban/assert-violation"}}');var i=r(5105),s=r(7890);const o={},a="Iterators over indexing",d={},c=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"iterators-over-indexing",children:"Iterators over indexing"})}),"\n",(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Category: ",(0,i.jsx)(t.code,{children:"Best practices"})]}),"\n",(0,i.jsxs)(t.li,{children:["Severity: ",(0,i.jsx)(t.code,{children:"Enhancement"})]}),"\n",(0,i.jsxs)(t.li,{children:["Detector: ",(0,i.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/iterators-over-indexing",children:(0,i.jsx)(t.code,{children:"iterators-over-indexing"})})]}),"\n",(0,i.jsxs)(t.li,{children:["Test Cases: ",(0,i.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1",children:(0,i.jsx)(t.code,{children:"iterators-over-indexing-1"})})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In Rust, sequences can be traversed using iterators or direct indexing. However, the least efficient way is through direct indexing."}),"\n",(0,i.jsx)(t.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,i.jsx)(t.p,{children:"When you iterate over a data structure with fixed limits in a Soroban smart contract, exceeding those limits can cause the contract to panic, potentially leading to errors or unexpected behavior."}),"\n",(0,i.jsx)(t.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,i.jsxs)(t.p,{children:["Consider the following ",(0,i.jsx)(t.code,{children:"Soroban"})," contract:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"   pub fn sum(e: Env) -> Result<i32, Error> {\n        let mut ret = 0_i32;\n        let vec = e\n            .storage()\n            .instance()\n            .get::<DataKey, Vec<i32>>(&DataKey::Data)\n            .ok_or(Error::NoData)?;\n        for i in 0..4 {\n            ret = ret\n                .checked_add(vec.get(i).ok_or(Error::NoData)?)\n                .ok_or(Error::IntegerOverflow)?;\n        }\n        Ok(ret)\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The problem arises in the for loop. If ",(0,i.jsx)(t.code,{children:"vec"})," has less than 4 elements, the contract will panic."]}),"\n",(0,i.jsxs)(t.p,{children:["The code example can be found ",(0,i.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1/vulnerable-example",children:"here"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"     pub fn sum(e: Env) -> Result<i32, Error> {\n        let mut ret = 0_i32;\n        let vec = e\n            .storage()\n            .instance()\n            .get::<DataKey, Vec<i32>>(&DataKey::Data)\n            .ok_or(Error::NoData)?;\n        for i in vec {\n            ret = ret.checked_add(i).ok_or(Error::IntegerOverflow)?;\n        }\n        Ok(ret)\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Instead of using a fixed loop, iterate through the vector itself using ",(0,i.jsx)(t.code,{children:"for i in vec"}),". This ensures the loop iterates only for valid elements present in the vector."]}),"\n",(0,i.jsxs)(t.p,{children:["The remediated code example can be found ",(0,i.jsx)(t.a,{href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1/remediated-example",children:"here"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,i.jsx)(t.p,{children:"It warns if the for loop uses indexing instead of iterator. If the indexing goes to length it will not raise a warning."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},7890:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>a});var n=r(8101);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);