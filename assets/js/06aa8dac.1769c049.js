"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1803],{3774:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var n=t(6672);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}},9143:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"detectors/substrate/avoid-unsafe-block","title":"Avoid unsafe block","description":"Description","source":"@site/docs/detectors/substrate/avoid-unsafe-block.md","sourceDirName":"detectors/substrate","slug":"/detectors/substrate/avoid-unsafe-block","permalink":"/scout-audit/docs/detectors/substrate/avoid-unsafe-block","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/substrate/avoid-unsafe-block.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Avoid panic error","permalink":"/scout-audit/docs/detectors/substrate/avoid-panic-error"},"next":{"title":"Divide before multiply","permalink":"/scout-audit/docs/detectors/substrate/divide-before-multiply"}}');var i=t(3420),a=t(3774);const r={},o="Avoid unsafe block",l={},d=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"avoid-unsafe-block",children:"Avoid unsafe block"})}),"\n",(0,i.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Category: ",(0,i.jsx)(s.code,{children:"Validations and error handling"})]}),"\n",(0,i.jsxs)(s.li,{children:["Severity: ",(0,i.jsx)(s.code,{children:"Critical"})]}),"\n",(0,i.jsxs)(s.li,{children:["Detector: ",(0,i.jsx)(s.a,{href:"https://github.com/CoinFabrik/scout-audit/blob/main/detectors/rust/avoid-unsafe-block/src/lib.rs",children:(0,i.jsx)(s.code,{children:"avoid-unsafe-block"})})]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The use of unsafe blocks in Rust is generally discouraged due to the potential risks it poses to the safety and reliability of the code. Rust's primary appeal lies in its ability to provide memory safety guarantees, which are largely enforced through its ownership and type systems. When you enter an unsafe block, you're effectively bypassing these safety checks. These blocks require the programmer to manually ensure that memory is correctly managed and accessed, which is prone to human error and can be challenging even for experienced developers. Therefore, unsafe blocks should only be used when absolutely necessary and when the safety of the operations within can be assured."}),"\n",(0,i.jsx)(s.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"unsafe"})," blocks should not be used unless absolutely necessary. The use of unsafe blocks in Rust is discouraged because they bypass Rust's memory safety checks, potentially leading to issues like undefined behavior and security vulnerabilities."]}),"\n",(0,i.jsx)(s.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,i.jsxs)(s.p,{children:["Consider the following ",(0,i.jsx)(s.code,{children:"substrate pallet"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"#[pallet::call_index(0)]\n        pub fn process_data(origin: OriginFor<T>, input: u8) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let result = unsafe {\n                let ptr: *const u8 = &input;\n                let value = *ptr;\n                value.rotate_left(2).wrapping_add(1)\n            };\n\n            DataStorage::<T>::set(result);\n\n            Self::deposit_event(Event::DataProcessed { who, value: result });\n\n            Ok(())\n        }\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In this example we can see that it creates a raw pointer named ",(0,i.jsx)(s.code,{children:"ptr"}),". Then ",(0,i.jsx)(s.code,{children:"value"})," dereferences the raw pointer. This directly accesses the memory location and calls the ",(0,i.jsx)(s.code,{children:"rotate_left"})," method on the value stored at that location."]}),"\n",(0,i.jsx)(s.p,{children:"Raw pointers bypass Rust's type safety system and memory management features. If something goes wrong with the calculations or the value of input, dereferencing the pointer could lead to a memory access violations or undefined behavior."}),"\n",(0,i.jsx)(s.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,i.jsx)(s.p,{children:"By removing the raw pointer, the following version eliminates the issue associated with dereferencing memory in an unsafe way. Rust's type safety checks ensure memory is accessed correctly, preventing the potential issues mentioned earlier."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"#[pallet::call_index(0)]\n        pub fn process_data(origin: OriginFor<T>, input: u8) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let result = input.rotate_left(2).wrapping_add(1);\n\n            DataStorage::<T>::set(result);\n\n            Self::deposit_event(Event::DataProcessed { who, value: result });\n\n            Ok(())\n        }\n"})}),"\n",(0,i.jsx)(s.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,i.jsxs)(s.p,{children:["Checks for usage of ",(0,i.jsx)(s.code,{children:"unsafe"})," blocks."]})]})}function u(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);