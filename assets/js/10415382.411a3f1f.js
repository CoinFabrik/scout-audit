"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9499],{9473:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"detectors/rust/divide-before-multiply","title":"Divide before multiply","description":"Description","source":"@site/docs/detectors/rust/divide-before-multiply.md","sourceDirName":"detectors/rust","slug":"/detectors/rust/divide-before-multiply","permalink":"/scout-audit/docs/detectors/rust/divide-before-multiply","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/detectors/rust/divide-before-multiply.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Avoid unsafe block","permalink":"/scout-audit/docs/detectors/rust/avoid-unsafe-block"},"next":{"title":"Empty expect","permalink":"/scout-audit/docs/detectors/rust/empty-expect"}}');var r=t(5105),n=t(6755);const o={},d="Divide before multiply",c={},l=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2},{value:"References",id:"references",level:2}];function a(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"divide-before-multiply",children:"Divide before multiply"})}),"\n",(0,r.jsx)(i.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Category: ",(0,r.jsx)(i.code,{children:"Arithmetic"})]}),"\n",(0,r.jsxs)(i.li,{children:["Severity: ",(0,r.jsx)(i.code,{children:"Medium"})]}),"\n",(0,r.jsxs)(i.li,{children:["Detectors: ",(0,r.jsx)(i.a,{href:"https://github.com/CoinFabrik/scout-audit/blob/main/detectors/rust/divide-before-multiply/src/lib.rs",children:(0,r.jsx)(i.code,{children:"divide-before-multiply"})})]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"In Rust, the order of operations can influence the precision of the result, especially in integer arithmetic."}),"\n",(0,r.jsx)(i.h2,{id:"why-is-this-bad",children:"Why is this bad?"}),"\n",(0,r.jsx)(i.p,{children:"Performing a division operation before a multiplication can lead to a loss of precision as division between integers might return zero."}),"\n",(0,r.jsx)(i.h2,{id:"issue-example",children:"Issue example"}),"\n",(0,r.jsx)(i.p,{children:"Consider the following snippet code:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:" pub fn split_profit(percentage: u64, total_profit: u64) -> u64 {\n    (percentage / 100) * total_profit\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["In this contract, the ",(0,r.jsx)(i.code,{children:"split_profit"})," function divides the ",(0,r.jsx)(i.code,{children:"percentage"})," by ",(0,r.jsx)(i.code,{children:"100"})," before multiplying it with ",(0,r.jsx)(i.code,{children:"total_profit"}),". This could lead to a loss of precision if ",(0,r.jsx)(i.code,{children:"percentage"})," is less than ",(0,r.jsx)(i.code,{children:"100"})," as the division would return ",(0,r.jsx)(i.code,{children:"0"}),". This could lead to incorrect calculations and potential financial loss in a real-world smart contract."]}),"\n",(0,r.jsx)(i.h2,{id:"remediated-example",children:"Remediated example"}),"\n",(0,r.jsx)(i.p,{children:"Reverse the order of operations to ensure multiplication occurs before division."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"pub fn split_profit(&self, percentage: u64, total_profit: u64) -> u64 {\n    (percentage * total_profit) / 100\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"how-is-it-detected",children:"How is it detected?"}),"\n",(0,r.jsx)(i.p,{children:"Checks the existence of a division before a multiplication."}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsxs)(i.a,{href:"https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators",children:["Rust documentation: ",(0,r.jsx)(i.code,{children:"Integer Division"})]})})]})}function u(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},6755:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>d});var s=t(8101);const r={},n=s.createContext(r);function o(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);